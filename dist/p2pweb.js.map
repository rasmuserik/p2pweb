{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 92dfb5e397ead6c62866","webpack:///./src/window.js","webpack:///./src/browser.js","webpack:///./src/Node.js","webpack:///./src/HashAddress.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA,+CAA+C;AAC/C;;;;;;;;;;;;;;ACDA;AACA;AACA;;;;;;;ACFA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,yBAAyB,qCAAqC;AAC9D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;ACxJA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"dist/p2pweb.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 92dfb5e397ead6c62866","const window = typeof self === 'undefined' ? {} : self;\nmodule.exports = window;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/window.js\n// module id = 0\n// module chunks = 0","const window = require('./window');\nconst Node = require('./Node');\nwindow.Node = Node;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser.js\n// module id = 2\n// module chunks = 0","// # Node\nHashAddress = require('./HashAddress');\n\nlet nodes = [];\n/**\n  */\nthis.exports = class Node {\n  /**\n    */\n  constructor({ bootstrapNodes }) {\n    nodes.push(this);\n\n    this.bootstrapNodes = bootstrapNodes;\n    this.connections = [];\n    this.rpc = {};\n\n    for (const method in rpc) {\n      this.rpc[method] = rpc[method].bind(this);\n    }\n\n    (async () => {\n      // TODO generate through DSA-key here later (bad random for the moment).\n      this.myAddress = await HashAddress.generate(\n        String(Math.random())\n      );\n      this.bootstrap();\n    })();\n  }\n\n  /**\n     * List of all known peers (one hop from current node)\n     */\n  allPeers() {\n    let peers = Object.keys(\n      pairsToObject(\n        this.connections\n          .map(o => o.addr)\n          .concat.apply([], this.connections.map(o => o.peers))\n          .map(s => [s, true])\n      )\n    ).filter(o => o !== this.address().toString());\n    return peers;\n  }\n\n  /**\n     * @private\n    */\n  bootstrap() {\n    if (!this.bootstrapping && this.connections.length === 0) {\n      this.bootstrapping = true;\n      setTimeout(() => {\n        this.bootstrapping = false;\n        this.bootstrap();\n      }, 1000);\n\n      const o = { close: () => {} };\n      platform.receiveSignalling(o);\n      o.onmessage({\n        data: {\n          websocket:\n            bootstrapNodes[(Math.random() * bootstrapNodes.length) | 0]\n        }\n      });\n    }\n  }\n\n  /**\n    */\n  send(addr, msg) {\n    const c = this.findConnection(addr);\n    if (c) {\n      c.con.send(msg);\n    } else if (this.address().toString() === addr) {\n      this.local(msg);\n    } else if (this.allPeers().includes(addr)) {\n      for (const peer of this.connections) {\n        if (peer.peers.includes(addr)) {\n          peer.con.send({ rpc: \"relay\", dst: addr, data: msg });\n          break;\n        }\n      }\n    } else {\n      print(\"no connection to \" + String(addr).slice(0, 4), msg);\n      print(this.allPeers().map(s => s.slice(0, 4)));\n      throw new Error();\n    }\n  }\n\n  /**\n    */\n  local(msg) {\n    if (this.rpc[msg.data.rpc]) {\n      this.rpc[msg.data.rpc](msg);\n    } else {\n      print(\"no such endpoint \" + JSON.stringify(msg.data));\n    }\n  }\n\n  /**\n    */\n  findConnection(addr) {\n    return this.connections.find(o => o.addr === addr);\n  }\n\n  /**\n    */\n  address() {\n    return this.myAddress;\n  }\n\n  /**\n    */\n  name() {\n    return this.address()\n      .toString()\n      .slice(0, 4);\n  }\n\n  /**\n    */\n  addConnection(con) {\n    let name = \"\";\n\n    const peer = { con };\n    peer.con.onmessage = msg => this.local(msg);\n\n    peer.con.onclose = () => {\n      const addr = (this.connections.find(o => o.con === peer.con) ||\n        {}).addr;\n      this.connections = this.connections.filter(\n        o => o.con !== peer.con\n      );\n      print(\"close\", (con.addr || \"????\").slice(0, 4));\n\n      if (addr) {\n        for (const peer of this.connections.map(o => o.addr)) {\n          this.send(peer, { rpc: \"lostPeer\", addr: addr });\n        }\n      }\n    };\n\n    peer.con.t2 = Date.now() + Math.random();\n    peer.con.send({\n      time: peer.con.t2,\n      weigh: 1 + Math.random(),\n      rpc: \"connect\",\n      addr: this.address().toString(),\n      peers: this.connections.map(o => o.addr),\n      isNodeJs: isNodeJs\n    });\n    print(\"addconnection\");\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Node.js\n// module id = 3\n// module chunks = 0","// # Hash Address\n\nconst window = require('./window');\nconsole.log(window.crypto);\n/**\n * Hashes as addresses, and utility functions for Kademlia-like routing.\n */\nmodule.exports = class HashAddress {\n  constructor(o) {\n    if (o instanceof Uint8Array && o.length === 32) {\n      this.data = o;\n    } else {\n      throw new Error();\n    }\n  }\n\n  /**\n    */\n  static async generate(src /*ArrayBuffer | String*/) {\n    if (typeof src === \"string\") {\n      src = ascii2buf(src);\n    } else {\n      assert(src instanceof ArrayBuffer);\n    }\n    let hash = await window.crypto.subtle.digest(\"SHA-256\", src);\n    return new HashAddress(new Uint8Array(hash));\n  }\n\n  /**\n    */\n  equals(addr) {\n    for (let i = 0; i < 32; ++i) {\n      if (this.data[i] !== addr.data[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n    */\n  static async TEST_constructor_generate_equals() {\n    let a = await HashAddress.generate(\"hello world\");\n    let b = await HashAddress.generate(\"hello world\");\n    let c = await HashAddress.generate(\"hello wÃ¸rld\");\n    a.equals(b) || throwError(\"equals1\");\n    !a.equals(c) || throwError(\"equals2\");\n  }\n\n  /**\n    */\n  static fromUint8Array(buf) {\n    return new HashAddress(buf.slice());\n  }\n\n  /**\n    */\n  static fromArrayBuffer(buf) {\n    return HashAddress.fromUint8Array(new Uint8Array(buf));\n  }\n\n  /**\n    */\n  static fromString(str) {\n    return HashAddress.fromArrayBuffer(ascii2buf(atob(str)));\n  }\n\n  /**\n    */\n  static fromHex(str) {\n    return HashAddress.fromArrayBuffer(hex2buf(str));\n  }\n\n  /**\n    */\n  toArrayBuffer() {\n    return this.data.slice().buffer;\n  }\n\n  /**\n    */\n  toString() {\n    return btoa(buf2ascii(this.toArrayBuffer()));\n  }\n\n  /**\n    */\n  toHex() {\n    return buf2hex(this.toArrayBuffer());\n  }\n\n  static async TEST_from_toArrayBuffer_toString() {\n    let a = await HashAddress.generate(\"hello\");\n    let b = HashAddress.fromArrayBuffer(a.toArrayBuffer());\n    let c = HashAddress.fromString(a.toString());\n    let x80 = HashAddress.fromString(\n      \"gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n    );\n    a.equals(b) || throwError();\n    a.equals(c) || throwError();\n    x80.toHex().startsWith(\"800\") || throwError();\n  }\n\n  /**\n   * xor-distance between two addresses, - with 24 significant bits, \n   * and with an offset such that the distance between `0x000..` \n   * and `0x800...` is `2 ** 123`, and distance `0b1111..` and \n   * `0b1010111..` is `2**122 + 2**120`. \n   * This also means that the distance can be represented \n   * within a single precision float. (with some loss on least significant bits)\n   */\n  dist(addr) {\n    let a = new Uint8Array(this.data);\n    let b = new Uint8Array(addr.data);\n    for (let i = 0; i < 32; ++i) {\n      if (a[i] !== b[i]) {\n        return (\n          2 ** (93 - i * 8) *\n          (((a[i] ^ b[i]) << 23) |\n            ((a[i + 1] ^ b[i + 1]) << 15) |\n            ((a[i + 2] ^ b[i + 2]) << 7) |\n            ((a[i + 3] ^ b[i + 3]) >> 1))\n        );\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * index of first bit in addr that is different. \n   */\n  distBit(addr) {\n    return HashAddress.distBit(this.dist(addr));\n  }\n\n  /*\n   * addr1.logDist(addr2) === HashAddress.logDist(addr1.dist(addr2))\n   */\n  static distBit(dist) {\n    return 123 - Math.floor(Math.log2(dist));\n  }\n\n  static TEST_dist() {\n    let h;\n    let zero = HashAddress.fromHex(\n      \"0000000000000000000000000000000000000000000000000000000000000000\"\n    );\n\n    h = HashAddress.fromHex(\n      \"0000000000000000000000000000001000000000000000000000000000000000\"\n    );\n    zero.dist(h) === 1 || throwError();\n\n    h = HashAddress.fromHex(\n      \"8000000000000000000000000000000000000000000000000000000000000000\"\n    );\n    zero.dist(h) === 2 ** 123 || throwError();\n    zero.distBit(h) === 0 || throwError();\n\n    h = HashAddress.fromHex(\n      \"0000000000000000000000000000000000000000000000000000000000000001\"\n    );\n    zero.dist(h) === 2 ** -132 || throwError();\n    zero.distBit(h) === 255 || throwError();\n\n    h = HashAddress.fromHex(\n      \"0f00000000000000000000000000000000000000000000000000000000000000\"\n    );\n    zero.distBit(h) === 4 || throwError();\n  }\n\n  /**\n   * Flip the bit at pos, and randomise every bit after that\n   */\n  flipBitRandomise(pos) {\n    let src = new Uint8Array(this.data);\n    let dst = src.slice();\n    let bytepos = pos >> 3;\n    window.crypto.getRandomValues(dst.subarray(bytepos));\n\n    let mask = 0xff80 >> (pos & 7);\n    let inverse = 0x80 >> (pos & 7);\n    dst[pos >> 3] =\n      (src[bytepos] & mask) | ((dst[bytepos] & ~mask) ^ inverse);\n\n    return new HashAddress(dst);\n  }\n\n  static TEST_flipBitRandomise() {\n    let zero = HashAddress.fromHex(\n      \"0000000000000000000000000000000000000000000000000000000000000000\"\n    );\n\n    zero\n      .flipBitRandomise(3)\n      .toHex()\n      .startsWith(\"1\") || throwError();\n    zero\n      .flipBitRandomise(7)\n      .toHex()\n      .startsWith(\"01\") || throwError();\n    zero\n      .flipBitRandomise(7 + 8)\n      .toHex()\n      .startsWith(\"0001\") || throwError();\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HashAddress.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}